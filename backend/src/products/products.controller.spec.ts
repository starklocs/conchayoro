import { Test } from '@nestjs/testing';
import { getModelToken } from '@nestjs/sequelize';
import { ProductsController } from './products.controller';
import { ProductsService } from './products.service';
import { Product } from './product.model'; // ✅ caminho único e consistente
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';

// This is plain JavaScript data, not a true 'Product' Sequelize instance.
// It's useful for defining DTOs or for the *data aspect* of a Product mock.
const productPlainData = {
  id: '1', // Usually, ID is generated by the database, so it might not be in CreateProductDto
  name: 'Product1',
  price: 10,
  category: 'C1',
  rating: 1,
  // Add any other relevant properties your Product entity has.
  // A real Sequelize instance would also have methods like save(), update(), etc.
  // and properties like createdAt, updatedAt if timestamps are enabled.
};

// DTOs for testing controller method inputs
const createProductDto: CreateProductDto = {
  name: 'Product1',
  price: 10,
  category: 'C1',
  rating: 1,
  // Ensure this matches your actual CreateProductDto definition
};

const updateProductDto: UpdateProductDto = {
  // UpdateDTOs often contain optional fields
  name: 'Product1 Updated',
  price: 12,
  category: '',
  rating: 0
};

describe('ProductsController', () => {
  let productsService: ProductsService;
  let productsController: ProductsController;

  // A more structured (though still simple) mock for the Product Sequelize model.
  // This is injected into ProductsService. Since we are directly mocking
  // ProductsService methods in these controller tests, the exact implementation
  // of mockProductModel is less critical here, but it's good practice.
  const mockProductModel = {
    create: jest.fn(),
    findAll: jest.fn(),
    findByPk: jest.fn(),
    update: jest.fn(), // Static model update
    destroy: jest.fn(),
    // Mock any other static methods of Product model used by ProductsService
    // if you were testing the service more deeply or not mocking its methods directly.
  };

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      controllers: [ProductsController],
      providers: [
        ProductsService, // We provide the real service but will mock its methods
        {
          provide: getModelToken(Product), // Mock for Product repository dependency
          useValue: mockProductModel,
        },
      ],
    }).compile();

    productsService = moduleRef.get<ProductsService>(ProductsService);
    productsController = moduleRef.get<ProductsController>(ProductsController);
  });

  afterEach(() => {
    jest.clearAllMocks(); // Good practice to clear mocks after each test
  });

  describe('create', () => {
    it('should create and return a product', async () => {
      // This is what we expect productsService.create to return.
      // We use "as unknown as Product" because productPlainData is not a full Sequelize instance,
      // but for this controller test, we assume the controller just passes through the data.
      // This addresses the TS2352 error.
      const expectedProduct: Product = {
        ...productPlainData,
        // If your actual Product entity automatically gets createdAt/updatedAt,
        // you might want to mock them here if your controller/DTO includes them.
        // createdAt: new Date(),
        // updatedAt: new Date(),
      } as unknown as Product;

      jest.spyOn(productsService, 'create').mockResolvedValue(expectedProduct);

      const result = await productsController.create(createProductDto);
      expect(result).toBe(expectedProduct); // Or .toEqual(expectedProduct) if it's a new object with same data
      expect(productsService.create).toHaveBeenCalledWith(createProductDto);
    });
  });

  describe('update', () => {
    it('should update a product and return the updated product', async () => {
      const productId = '1';
      const updatedProductData = {
        ...productPlainData, // Start with base data
        ...updateProductDto, // Override with update DTO fields
        id: productId,       // Ensure ID is consistent
      };

      // **Crucial for addressing potential TS2345 error**:
      // productsService.update should be mocked to return what the controller expects.
      // If the controller expects the updated Product object, mock that.
      const expectedUpdatedProduct: Product = updatedProductData as unknown as Product;

      jest.spyOn(productsService, 'update').mockResolvedValue(expectedUpdatedProduct);

      const result = await productsController.update(productId, updateProductDto);
      expect(result).toBe(expectedUpdatedProduct); // Or .toEqual()
      expect(productsService.update).toHaveBeenCalledWith(productId, updateProductDto);
    });

    it('should handle product not found on update by returning null (example)', async () => {
      const productId = 'non-existent-id';
      // Assuming your service's update method returns null if the product isn't found
      // and the controller propagates this.
      jest.spyOn(productsService, 'update').mockResolvedValue(null);

      const result = await productsController.update(productId, updateProductDto);
      expect(result).toBeNull();
      expect(productsService.update).toHaveBeenCalledWith(productId, updateProductDto);
      // If your controller throws a NotFoundException, you'd test that instead:
      // await expect(productsController.update(productId, updateProductDto)).rejects.toThrow(NotFoundException);
    });
  });

  describe('remove', () => {
    it('should delete a product and return undefined (or confirmation)', async () => {
      const productId = '1';
      // Assuming productsService.remove resolves to void or undefined on success
      jest.spyOn(productsService, 'remove').mockResolvedValue(undefined);

      const result = await productsController.remove(productId);
      expect(result).toBeUndefined();
      expect(productsService.remove).toHaveBeenCalledWith(productId);
    });
  });

  describe('findAll', () => {
    it('should return an array of products', async () => {
      const mockProductsArray: Product[] = [
        { ...productPlainData, id: '1' } as unknown as Product,
        { ...productPlainData, id: '2', name: 'Product2' } as unknown as Product,
      ];
      jest.spyOn(productsService, 'findAll').mockResolvedValue(mockProductsArray);

      const result = await productsController.findAll();
      expect(result).toEqual(mockProductsArray); // Use .toEqual for deep array/object comparison
      expect(productsService.findAll).toHaveBeenCalled();
    });

    it('should return an empty array if no products are found', async () => {
        const mockProductsArray: Product[] = [];
        jest.spyOn(productsService, 'findAll').mockResolvedValue(mockProductsArray);

        const result = await productsController.findAll();
        expect(result).toEqual([]);
        expect(productsService.findAll).toHaveBeenCalled();
    });
  });

  describe('findOne', () => {
    it('should return a specific product by id', async () => {
      const productId = '1';
      const expectedProduct: Product = { ...productPlainData, id: productId } as unknown as Product;
      jest.spyOn(productsService, 'findOne').mockResolvedValue(expectedProduct);

      const result = await productsController.findOne(productId);
      expect(result).toBe(expectedProduct); // Or .toEqual()
      expect(productsService.findOne).toHaveBeenCalledWith(productId);
    });

    it('should return null if a specific product is not found (example)', async () => {
        const productId = 'non-existent-id';
        // Assuming service returns null if not found and controller propagates this
        jest.spyOn(productsService, 'findOne').mockResolvedValue(null);

        const result = await productsController.findOne(productId);
        expect(result).toBeNull();
        expect(productsService.findOne).toHaveBeenCalledWith(productId);
        // Or test for NotFoundException if thrown by the controller
    });
  });

  describe('findByCriteria', () => {
    // Assuming you have a findByCriteria method
    it('should return an array of products matching criteria', async () => {
      const criteria = { category: 'C1' };
      const mockProductsArray: Product[] = [
        { ...productPlainData, id: '1', category: 'C1' } as unknown as Product,
      ];
      jest.spyOn(productsService, 'findByCriteria').mockResolvedValue(mockProductsArray);

      const result = await productsController.findByCriteria(criteria);
      expect(result).toEqual(mockProductsArray);
      expect(productsService.findByCriteria).toHaveBeenCalledWith(criteria);
    });
  });
});